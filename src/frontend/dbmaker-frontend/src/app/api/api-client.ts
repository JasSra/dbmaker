//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class DbMakerApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Test endpoint that doesn't require authentication
     * @return OK
     */
    anonymous(): Observable<void> {
        let url_ = this.baseUrl + "/api/AuthDebug/anonymous";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnonymous(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnonymous(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAnonymous(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Test endpoint that requires authentication
     * @return OK
     */
    authenticated(): Observable<void> {
        let url_ = this.baseUrl + "/api/AuthDebug/authenticated";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticated(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuthenticated(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Test custom token validation directly
     * @param body (optional) 
     * @return OK
     */
    validateToken(body: TokenValidationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AuthDebug/validate-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processValidateToken(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get current authentication status and token information
     * @return OK
     */
    status(): Observable<void> {
        let url_ = this.baseUrl + "/api/AuthDebug/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get detailed information about the current JWT token
     * @return OK
     */
    tokenInfo(): Observable<void> {
        let url_ = this.baseUrl + "/api/AuthDebug/token-info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTokenInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTokenInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTokenInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    containersAll(): Observable<ContainerResponse[]> {
        let url_ = this.baseUrl + "/api/Containers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContainersAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContainersAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContainerResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContainerResponse[]>;
        }));
    }

    protected processContainersAll(response: HttpResponseBase): Observable<ContainerResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContainerResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    containersPOST(body: CreateContainerRequest | undefined): Observable<ContainerResponse> {
        let url_ = this.baseUrl + "/api/Containers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContainersPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContainersPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContainerResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContainerResponse>;
        }));
    }

    protected processContainersPOST(response: HttpResponseBase): Observable<ContainerResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContainerResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    containersGET(id: string): Observable<ContainerResponse> {
        let url_ = this.baseUrl + "/api/Containers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContainersGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContainersGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContainerResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContainerResponse>;
        }));
    }

    protected processContainersGET(response: HttpResponseBase): Observable<ContainerResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContainerResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    containersDELETE(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Containers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContainersDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContainersDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processContainersDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    start(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Containers/{id}/start";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    stop(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Containers/{id}/stop";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStop(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStop(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    stats(id: string): Observable<ContainerMonitoringData> {
        let url_ = this.baseUrl + "/api/Containers/{id}/stats";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContainerMonitoringData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContainerMonitoringData>;
        }));
    }

    protected processStats(response: HttpResponseBase): Observable<ContainerMonitoringData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContainerMonitoringData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    allDebug(): Observable<void> {
        let url_ = this.baseUrl + "/api/Containers/all-debug";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllDebug(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllDebug(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAllDebug(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createDemo(): Observable<void> {
        let url_ = this.baseUrl + "/api/Containers/create-demo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDemo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDemo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateDemo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    cleanupDemo(): Observable<void> {
        let url_ = this.baseUrl + "/api/Containers/cleanup-demo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCleanupDemo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCleanupDemo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCleanupDemo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    databaseDebug(): Observable<void> {
        let url_ = this.baseUrl + "/api/Containers/database-debug";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDatabaseDebug(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDatabaseDebug(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDatabaseDebug(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    emergencyReset(): Observable<void> {
        let url_ = this.baseUrl + "/api/Containers/emergency-reset";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmergencyReset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmergencyReset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEmergencyReset(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    health(): Observable<void> {
        let url_ = this.baseUrl + "/Health";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHealth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHealth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processHealth(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get real-time statistics for all user containers
     * @return OK
     */
    statsAll(): Observable<ContainerMonitoringData[]> {
        let url_ = this.baseUrl + "/api/Monitoring/stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContainerMonitoringData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContainerMonitoringData[]>;
        }));
    }

    protected processStatsAll(response: HttpResponseBase): Observable<ContainerMonitoringData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContainerMonitoringData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get statistics for a specific container
     * @return OK
     */
    stats2(containerId: string): Observable<ContainerMonitoringData> {
        let url_ = this.baseUrl + "/api/Monitoring/stats/{containerId}";
        if (containerId === undefined || containerId === null)
            throw new Error("The parameter 'containerId' must be defined.");
        url_ = url_.replace("{containerId}", encodeURIComponent("" + containerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStats2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStats2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContainerMonitoringData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContainerMonitoringData>;
        }));
    }

    protected processStats2(response: HttpResponseBase): Observable<ContainerMonitoringData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContainerMonitoringData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get system-wide monitoring summary (admin only)
     * @return OK
     */
    summary(): Observable<MonitoringSummary> {
        let url_ = this.baseUrl + "/api/Monitoring/summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MonitoringSummary>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MonitoringSummary>;
        }));
    }

    protected processSummary(response: HttpResponseBase): Observable<MonitoringSummary> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MonitoringSummary.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get container logs (if available)
     * @param lines (optional) 
     * @return OK
     */
    logs(containerId: string, lines: number | undefined): Observable<ContainerLogs> {
        let url_ = this.baseUrl + "/api/Monitoring/logs/{containerId}?";
        if (containerId === undefined || containerId === null)
            throw new Error("The parameter 'containerId' must be defined.");
        url_ = url_.replace("{containerId}", encodeURIComponent("" + containerId));
        if (lines === null)
            throw new Error("The parameter 'lines' cannot be null.");
        else if (lines !== undefined)
            url_ += "lines=" + encodeURIComponent("" + lines) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContainerLogs>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContainerLogs>;
        }));
    }

    protected processLogs(response: HttpResponseBase): Observable<ContainerLogs> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContainerLogs.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Test container connectivity
     * @return OK
     */
    test(containerId: string): Observable<ContainerTestResult> {
        let url_ = this.baseUrl + "/api/Monitoring/test/{containerId}";
        if (containerId === undefined || containerId === null)
            throw new Error("The parameter 'containerId' must be defined.");
        url_ = url_.replace("{containerId}", encodeURIComponent("" + containerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContainerTestResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContainerTestResult>;
        }));
    }

    protected processTest(response: HttpResponseBase): Observable<ContainerTestResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContainerTestResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    settingsGET(): Observable<SettingsResponse> {
        let url_ = this.baseUrl + "/api/Settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSettingsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSettingsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingsResponse>;
        }));
    }

    protected processSettingsGET(response: HttpResponseBase): Observable<SettingsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    settingsPUT(body: UpdateSettingsRequest | undefined): Observable<SettingsResponse> {
        let url_ = this.baseUrl + "/api/Settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSettingsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSettingsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingsResponse>;
        }));
    }

    protected processSettingsPUT(response: HttpResponseBase): Observable<SettingsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    globalGET(): Observable<SettingsResponse> {
        let url_ = this.baseUrl + "/api/Settings/global";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGlobalGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGlobalGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingsResponse>;
        }));
    }

    protected processGlobalGET(response: HttpResponseBase): Observable<SettingsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    globalPUT(body: UpdateSettingsRequest | undefined): Observable<SettingsResponse> {
        let url_ = this.baseUrl + "/api/Settings/global";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGlobalPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGlobalPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingsResponse>;
        }));
    }

    protected processGlobalPUT(response: HttpResponseBase): Observable<SettingsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    remoteHostPOST(body: RemoteDockerHost | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Settings/docker/remote-host";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoteHostPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoteHostPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoteHostPOST(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    remoteHostDELETE(hostId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Settings/docker/remote-host/{hostId}";
        if (hostId === undefined || hostId === null)
            throw new Error("The parameter 'hostId' must be defined.");
        url_ = url_.replace("{hostId}", encodeURIComponent("" + hostId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoteHostDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoteHostDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoteHostDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Check if the system needs initial setup
     * @return OK
     */
    status2(): Observable<SetupStatus> {
        let url_ = this.baseUrl + "/api/Setup/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SetupStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SetupStatus>;
        }));
    }

    protected processStatus2(response: HttpResponseBase): Observable<SetupStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SetupStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Validate Docker daemon connectivity
     * @return OK
     */
    docker(): Observable<ValidationResult> {
        let url_ = this.baseUrl + "/api/Setup/validate/docker";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocker(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocker(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValidationResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValidationResult>;
        }));
    }

    protected processDocker(response: HttpResponseBase): Observable<ValidationResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Validate MSAL configuration
     * @return OK
     */
    msal(): Observable<ValidationResult> {
        let url_ = this.baseUrl + "/api/Setup/validate/msal";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMsal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMsal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ValidationResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ValidationResult>;
        }));
    }

    protected processMsal(response: HttpResponseBase): Observable<ValidationResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Initialize the system with admin user and backup key
     * @param body (optional) 
     * @return OK
     */
    initialize(body: InitializeSystemRequest | undefined): Observable<InitializationResult> {
        let url_ = this.baseUrl + "/api/Setup/initialize";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInitialize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInitialize(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InitializationResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InitializationResult>;
        }));
    }

    protected processInitialize(response: HttpResponseBase): Observable<InitializationResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InitializationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param category (optional) 
     * @param q (optional) 
     * @return OK
     */
    templates(category: string | undefined, q: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Templates?";
        if (category === null)
            throw new Error("The parameter 'category' cannot be null.");
        else if (category !== undefined)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        if (q === null)
            throw new Error("The parameter 'q' cannot be null.");
        else if (q !== undefined)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTemplates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTemplates(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    templates2(key: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Templates/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTemplates2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTemplates2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTemplates2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    versions(key: string, version: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Templates/{key}/versions/{version}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVersions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVersions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVersions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param version (optional) 
     * @param overrides (optional) 
     * @return OK
     */
    preview(key: string, version: string | undefined, overrides: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Templates/{key}/preview?";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        if (version === null)
            throw new Error("The parameter 'version' cannot be null.");
        else if (version !== undefined)
            url_ += "version=" + encodeURIComponent("" + version) + "&";
        if (overrides === null)
            throw new Error("The parameter 'overrides' cannot be null.");
        else if (overrides !== undefined)
            url_ += "overrides=" + encodeURIComponent("" + overrides) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPreview(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createContainer(body: TestCreateContainerRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/test/create-container";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContainer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContainer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateContainer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    port(): Observable<void> {
        let url_ = this.baseUrl + "/api/test/port";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPort(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPort(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPort(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    subdomain(userId: string, containerName: string, databaseType: string): Observable<void> {
        let url_ = this.baseUrl + "/api/test/subdomain/{userId}/{containerName}/{databaseType}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (containerName === undefined || containerName === null)
            throw new Error("The parameter 'containerName' must be defined.");
        url_ = url_.replace("{containerName}", encodeURIComponent("" + containerName));
        if (databaseType === undefined || databaseType === null)
            throw new Error("The parameter 'databaseType' must be defined.");
        url_ = url_.replace("{databaseType}", encodeURIComponent("" + databaseType));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubdomain(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubdomain(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubdomain(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    dockerStatus(): Observable<void> {
        let url_ = this.baseUrl + "/api/test/docker-status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDockerStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDockerStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDockerStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    me(): Observable<User> {
        let url_ = this.baseUrl + "/api/Users/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processMe(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    stats3(): Observable<void> {
        let url_ = this.baseUrl + "/api/Users/me/stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStats3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStats3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStats3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ContainerLogs implements IContainerLogs {
    containerId?: string | undefined;
    lines?: string[] | undefined;
    lastUpdated?: Date;

    constructor(data?: IContainerLogs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.containerId = _data["containerId"];
            if (Array.isArray(_data["lines"])) {
                this.lines = [] as any;
                for (let item of _data["lines"])
                    this.lines!.push(item);
            }
            this.lastUpdated = _data["lastUpdated"] ? new Date(_data["lastUpdated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContainerLogs {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerLogs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["containerId"] = this.containerId;
        if (Array.isArray(this.lines)) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item);
        }
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        return data;
    }
}

export interface IContainerLogs {
    containerId?: string | undefined;
    lines?: string[] | undefined;
    lastUpdated?: Date;
}

export class ContainerMonitoringData implements IContainerMonitoringData {
    containerId?: string | undefined;
    userId?: string | undefined;
    status?: ContainerStatus;
    cpuUsage?: number;
    memoryUsage?: number;
    memoryLimit?: number;
    networkIO?: { [key: string]: number; } | undefined;
    timestamp?: Date;
    isHealthy?: boolean;
    errorMessage?: string | undefined;

    constructor(data?: IContainerMonitoringData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.containerId = _data["containerId"];
            this.userId = _data["userId"];
            this.status = _data["status"];
            this.cpuUsage = _data["cpuUsage"];
            this.memoryUsage = _data["memoryUsage"];
            this.memoryLimit = _data["memoryLimit"];
            if (_data["networkIO"]) {
                this.networkIO = {} as any;
                for (let key in _data["networkIO"]) {
                    if (_data["networkIO"].hasOwnProperty(key))
                        (<any>this.networkIO)![key] = _data["networkIO"][key];
                }
            }
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.isHealthy = _data["isHealthy"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): ContainerMonitoringData {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerMonitoringData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["containerId"] = this.containerId;
        data["userId"] = this.userId;
        data["status"] = this.status;
        data["cpuUsage"] = this.cpuUsage;
        data["memoryUsage"] = this.memoryUsage;
        data["memoryLimit"] = this.memoryLimit;
        if (this.networkIO) {
            data["networkIO"] = {};
            for (let key in this.networkIO) {
                if (this.networkIO.hasOwnProperty(key))
                    (<any>data["networkIO"])[key] = (<any>this.networkIO)[key];
            }
        }
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["isHealthy"] = this.isHealthy;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IContainerMonitoringData {
    containerId?: string | undefined;
    userId?: string | undefined;
    status?: ContainerStatus;
    cpuUsage?: number;
    memoryUsage?: number;
    memoryLimit?: number;
    networkIO?: { [key: string]: number; } | undefined;
    timestamp?: Date;
    isHealthy?: boolean;
    errorMessage?: string | undefined;
}

export class ContainerResponse implements IContainerResponse {
    id?: string | undefined;
    name?: string | undefined;
    databaseType?: string | undefined;
    connectionString?: string | undefined;
    status?: ContainerStatus;
    subdomain?: string | undefined;
    port?: number;
    createdAt?: Date;
    configuration?: { [key: string]: string; } | undefined;

    constructor(data?: IContainerResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.databaseType = _data["databaseType"];
            this.connectionString = _data["connectionString"];
            this.status = _data["status"];
            this.subdomain = _data["subdomain"];
            this.port = _data["port"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
        }
    }

    static fromJS(data: any): ContainerResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["databaseType"] = this.databaseType;
        data["connectionString"] = this.connectionString;
        data["status"] = this.status;
        data["subdomain"] = this.subdomain;
        data["port"] = this.port;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        return data;
    }
}

export interface IContainerResponse {
    id?: string | undefined;
    name?: string | undefined;
    databaseType?: string | undefined;
    connectionString?: string | undefined;
    status?: ContainerStatus;
    subdomain?: string | undefined;
    port?: number;
    createdAt?: Date;
    configuration?: { [key: string]: string; } | undefined;
}

export class ContainerSettings implements IContainerSettings {
    showAllContainers?: boolean;
    showSystemContainers?: boolean;
    enableVisualization?: boolean;
    hiddenContainers?: string[] | undefined;

    constructor(data?: IContainerSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showAllContainers = _data["showAllContainers"];
            this.showSystemContainers = _data["showSystemContainers"];
            this.enableVisualization = _data["enableVisualization"];
            if (Array.isArray(_data["hiddenContainers"])) {
                this.hiddenContainers = [] as any;
                for (let item of _data["hiddenContainers"])
                    this.hiddenContainers!.push(item);
            }
        }
    }

    static fromJS(data: any): ContainerSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showAllContainers"] = this.showAllContainers;
        data["showSystemContainers"] = this.showSystemContainers;
        data["enableVisualization"] = this.enableVisualization;
        if (Array.isArray(this.hiddenContainers)) {
            data["hiddenContainers"] = [];
            for (let item of this.hiddenContainers)
                data["hiddenContainers"].push(item);
        }
        return data;
    }
}

export interface IContainerSettings {
    showAllContainers?: boolean;
    showSystemContainers?: boolean;
    enableVisualization?: boolean;
    hiddenContainers?: string[] | undefined;
}

export enum ContainerStatus {
    Creating = "Creating",
    Running = "Running",
    Stopped = "Stopped",
    Failed = "Failed",
    Removing = "Removing",
}

export class ContainerTestResult implements IContainerTestResult {
    containerId?: string | undefined;
    isReachable?: boolean;
    responseTime?: number;
    message?: string | undefined;
    testedAt?: Date;

    constructor(data?: IContainerTestResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.containerId = _data["containerId"];
            this.isReachable = _data["isReachable"];
            this.responseTime = _data["responseTime"];
            this.message = _data["message"];
            this.testedAt = _data["testedAt"] ? new Date(_data["testedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContainerTestResult {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerTestResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["containerId"] = this.containerId;
        data["isReachable"] = this.isReachable;
        data["responseTime"] = this.responseTime;
        data["message"] = this.message;
        data["testedAt"] = this.testedAt ? this.testedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IContainerTestResult {
    containerId?: string | undefined;
    isReachable?: boolean;
    responseTime?: number;
    message?: string | undefined;
    testedAt?: Date;
}

export class CreateContainerRequest implements ICreateContainerRequest {
    databaseType!: string;
    name!: string;
    userId?: string | undefined;
    configuration?: { [key: string]: string; } | undefined;

    constructor(data?: ICreateContainerRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.databaseType = _data["databaseType"];
            this.name = _data["name"];
            this.userId = _data["userId"];
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
        }
    }

    static fromJS(data: any): CreateContainerRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContainerRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databaseType"] = this.databaseType;
        data["name"] = this.name;
        data["userId"] = this.userId;
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        return data;
    }
}

export interface ICreateContainerRequest {
    databaseType: string;
    name: string;
    userId?: string | undefined;
    configuration?: { [key: string]: string; } | undefined;
}

export class DatabaseContainer implements IDatabaseContainer {
    id?: string | undefined;
    userId?: string | undefined;
    name?: string | undefined;
    databaseType?: string | undefined;
    containerName?: string | undefined;
    containerId?: string | undefined;
    port?: number;
    connectionString?: string | undefined;
    status?: ContainerStatus;
    createdAt?: Date;
    lastAccessedAt?: Date;
    configuration?: { [key: string]: string; } | undefined;
    subdomain?: string | undefined;
    user?: User;

    constructor(data?: IDatabaseContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.databaseType = _data["databaseType"];
            this.containerName = _data["containerName"];
            this.containerId = _data["containerId"];
            this.port = _data["port"];
            this.connectionString = _data["connectionString"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastAccessedAt = _data["lastAccessedAt"] ? new Date(_data["lastAccessedAt"].toString()) : <any>undefined;
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
            this.subdomain = _data["subdomain"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DatabaseContainer {
        data = typeof data === 'object' ? data : {};
        let result = new DatabaseContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["databaseType"] = this.databaseType;
        data["containerName"] = this.containerName;
        data["containerId"] = this.containerId;
        data["port"] = this.port;
        data["connectionString"] = this.connectionString;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastAccessedAt"] = this.lastAccessedAt ? this.lastAccessedAt.toISOString() : <any>undefined;
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        data["subdomain"] = this.subdomain;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDatabaseContainer {
    id?: string | undefined;
    userId?: string | undefined;
    name?: string | undefined;
    databaseType?: string | undefined;
    containerName?: string | undefined;
    containerId?: string | undefined;
    port?: number;
    connectionString?: string | undefined;
    status?: ContainerStatus;
    createdAt?: Date;
    lastAccessedAt?: Date;
    configuration?: { [key: string]: string; } | undefined;
    subdomain?: string | undefined;
    user?: User;
}

export class DockerSettings implements IDockerSettings {
    defaultHost?: string | undefined;
    enableMaintenance?: boolean;
    autoCleanup?: boolean;
    maintenanceInterval?: number;
    remoteHosts?: RemoteDockerHost[] | undefined;
    currentRemoteHost?: string | undefined;

    constructor(data?: IDockerSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultHost = _data["defaultHost"];
            this.enableMaintenance = _data["enableMaintenance"];
            this.autoCleanup = _data["autoCleanup"];
            this.maintenanceInterval = _data["maintenanceInterval"];
            if (Array.isArray(_data["remoteHosts"])) {
                this.remoteHosts = [] as any;
                for (let item of _data["remoteHosts"])
                    this.remoteHosts!.push(RemoteDockerHost.fromJS(item));
            }
            this.currentRemoteHost = _data["currentRemoteHost"];
        }
    }

    static fromJS(data: any): DockerSettings {
        data = typeof data === 'object' ? data : {};
        let result = new DockerSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultHost"] = this.defaultHost;
        data["enableMaintenance"] = this.enableMaintenance;
        data["autoCleanup"] = this.autoCleanup;
        data["maintenanceInterval"] = this.maintenanceInterval;
        if (Array.isArray(this.remoteHosts)) {
            data["remoteHosts"] = [];
            for (let item of this.remoteHosts)
                data["remoteHosts"].push(item.toJSON());
        }
        data["currentRemoteHost"] = this.currentRemoteHost;
        return data;
    }
}

export interface IDockerSettings {
    defaultHost?: string | undefined;
    enableMaintenance?: boolean;
    autoCleanup?: boolean;
    maintenanceInterval?: number;
    remoteHosts?: RemoteDockerHost[] | undefined;
    currentRemoteHost?: string | undefined;
}

export class InitializationResult implements IInitializationResult {
    adminUserCreated?: boolean;
    backupKey?: string | undefined;
    success?: boolean;
    message?: string | undefined;

    constructor(data?: IInitializationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminUserCreated = _data["adminUserCreated"];
            this.backupKey = _data["backupKey"];
            this.success = _data["success"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): InitializationResult {
        data = typeof data === 'object' ? data : {};
        let result = new InitializationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminUserCreated"] = this.adminUserCreated;
        data["backupKey"] = this.backupKey;
        data["success"] = this.success;
        data["message"] = this.message;
        return data;
    }
}

export interface IInitializationResult {
    adminUserCreated?: boolean;
    backupKey?: string | undefined;
    success?: boolean;
    message?: string | undefined;
}

export class InitializeSystemRequest implements IInitializeSystemRequest {
    adminEmail?: string | undefined;
    adminName?: string | undefined;
    domain?: string | undefined;
    additionalConfig?: { [key: string]: string; } | undefined;

    constructor(data?: IInitializeSystemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminEmail = _data["adminEmail"];
            this.adminName = _data["adminName"];
            this.domain = _data["domain"];
            if (_data["additionalConfig"]) {
                this.additionalConfig = {} as any;
                for (let key in _data["additionalConfig"]) {
                    if (_data["additionalConfig"].hasOwnProperty(key))
                        (<any>this.additionalConfig)![key] = _data["additionalConfig"][key];
                }
            }
        }
    }

    static fromJS(data: any): InitializeSystemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InitializeSystemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminEmail"] = this.adminEmail;
        data["adminName"] = this.adminName;
        data["domain"] = this.domain;
        if (this.additionalConfig) {
            data["additionalConfig"] = {};
            for (let key in this.additionalConfig) {
                if (this.additionalConfig.hasOwnProperty(key))
                    (<any>data["additionalConfig"])[key] = (<any>this.additionalConfig)[key];
            }
        }
        return data;
    }
}

export interface IInitializeSystemRequest {
    adminEmail?: string | undefined;
    adminName?: string | undefined;
    domain?: string | undefined;
    additionalConfig?: { [key: string]: string; } | undefined;
}

export class MonitoringSummary implements IMonitoringSummary {
    totalContainers?: number;
    runningContainers?: number;
    stoppedContainers?: number;
    failedContainers?: number;
    totalMemoryUsage?: number;
    averageCpuUsage?: number;
    unhealthyContainers?: number;
    lastUpdated?: Date;

    constructor(data?: IMonitoringSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalContainers = _data["totalContainers"];
            this.runningContainers = _data["runningContainers"];
            this.stoppedContainers = _data["stoppedContainers"];
            this.failedContainers = _data["failedContainers"];
            this.totalMemoryUsage = _data["totalMemoryUsage"];
            this.averageCpuUsage = _data["averageCpuUsage"];
            this.unhealthyContainers = _data["unhealthyContainers"];
            this.lastUpdated = _data["lastUpdated"] ? new Date(_data["lastUpdated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MonitoringSummary {
        data = typeof data === 'object' ? data : {};
        let result = new MonitoringSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalContainers"] = this.totalContainers;
        data["runningContainers"] = this.runningContainers;
        data["stoppedContainers"] = this.stoppedContainers;
        data["failedContainers"] = this.failedContainers;
        data["totalMemoryUsage"] = this.totalMemoryUsage;
        data["averageCpuUsage"] = this.averageCpuUsage;
        data["unhealthyContainers"] = this.unhealthyContainers;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        return data;
    }
}

export interface IMonitoringSummary {
    totalContainers?: number;
    runningContainers?: number;
    stoppedContainers?: number;
    failedContainers?: number;
    totalMemoryUsage?: number;
    averageCpuUsage?: number;
    unhealthyContainers?: number;
    lastUpdated?: Date;
}

export class NginxSettings implements INginxSettings {
    enableDynamicSubdomains?: boolean;
    baseDomain?: string | undefined;
    listenPort?: number;
    useGuidSubdomains?: boolean;
    subdomainMappings?: { [key: string]: string; } | undefined;

    constructor(data?: INginxSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enableDynamicSubdomains = _data["enableDynamicSubdomains"];
            this.baseDomain = _data["baseDomain"];
            this.listenPort = _data["listenPort"];
            this.useGuidSubdomains = _data["useGuidSubdomains"];
            if (_data["subdomainMappings"]) {
                this.subdomainMappings = {} as any;
                for (let key in _data["subdomainMappings"]) {
                    if (_data["subdomainMappings"].hasOwnProperty(key))
                        (<any>this.subdomainMappings)![key] = _data["subdomainMappings"][key];
                }
            }
        }
    }

    static fromJS(data: any): NginxSettings {
        data = typeof data === 'object' ? data : {};
        let result = new NginxSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enableDynamicSubdomains"] = this.enableDynamicSubdomains;
        data["baseDomain"] = this.baseDomain;
        data["listenPort"] = this.listenPort;
        data["useGuidSubdomains"] = this.useGuidSubdomains;
        if (this.subdomainMappings) {
            data["subdomainMappings"] = {};
            for (let key in this.subdomainMappings) {
                if (this.subdomainMappings.hasOwnProperty(key))
                    (<any>data["subdomainMappings"])[key] = (<any>this.subdomainMappings)[key];
            }
        }
        return data;
    }
}

export interface INginxSettings {
    enableDynamicSubdomains?: boolean;
    baseDomain?: string | undefined;
    listenPort?: number;
    useGuidSubdomains?: boolean;
    subdomainMappings?: { [key: string]: string; } | undefined;
}

export class RemoteDockerHost implements IRemoteDockerHost {
    id?: string | undefined;
    name?: string | undefined;
    host?: string | undefined;
    useTLS?: boolean;
    certPath?: string | undefined;
    keyPath?: string | undefined;
    isActive?: boolean;
    lastConnected?: Date;
    lastError?: string | undefined;

    constructor(data?: IRemoteDockerHost) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.host = _data["host"];
            this.useTLS = _data["useTLS"];
            this.certPath = _data["certPath"];
            this.keyPath = _data["keyPath"];
            this.isActive = _data["isActive"];
            this.lastConnected = _data["lastConnected"] ? new Date(_data["lastConnected"].toString()) : <any>undefined;
            this.lastError = _data["lastError"];
        }
    }

    static fromJS(data: any): RemoteDockerHost {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteDockerHost();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["host"] = this.host;
        data["useTLS"] = this.useTLS;
        data["certPath"] = this.certPath;
        data["keyPath"] = this.keyPath;
        data["isActive"] = this.isActive;
        data["lastConnected"] = this.lastConnected ? this.lastConnected.toISOString() : <any>undefined;
        data["lastError"] = this.lastError;
        return data;
    }
}

export interface IRemoteDockerHost {
    id?: string | undefined;
    name?: string | undefined;
    host?: string | undefined;
    useTLS?: boolean;
    certPath?: string | undefined;
    keyPath?: string | undefined;
    isActive?: boolean;
    lastConnected?: Date;
    lastError?: string | undefined;
}

export class SettingsResponse implements ISettingsResponse {
    settings?: SystemSettings;
    success?: boolean;
    message?: string | undefined;

    constructor(data?: ISettingsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.settings = _data["settings"] ? SystemSettings.fromJS(_data["settings"]) : <any>undefined;
            this.success = _data["success"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): SettingsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SettingsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        data["success"] = this.success;
        data["message"] = this.message;
        return data;
    }
}

export interface ISettingsResponse {
    settings?: SystemSettings;
    success?: boolean;
    message?: string | undefined;
}

export class SetupStatus implements ISetupStatus {
    databaseConfigured?: boolean;
    adminUserExists?: boolean;
    dockerConnected?: boolean;
    msalConfigured?: boolean;
    systemReady?: boolean;

    constructor(data?: ISetupStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.databaseConfigured = _data["databaseConfigured"];
            this.adminUserExists = _data["adminUserExists"];
            this.dockerConnected = _data["dockerConnected"];
            this.msalConfigured = _data["msalConfigured"];
            this.systemReady = _data["systemReady"];
        }
    }

    static fromJS(data: any): SetupStatus {
        data = typeof data === 'object' ? data : {};
        let result = new SetupStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["databaseConfigured"] = this.databaseConfigured;
        data["adminUserExists"] = this.adminUserExists;
        data["dockerConnected"] = this.dockerConnected;
        data["msalConfigured"] = this.msalConfigured;
        data["systemReady"] = this.systemReady;
        return data;
    }
}

export interface ISetupStatus {
    databaseConfigured?: boolean;
    adminUserExists?: boolean;
    dockerConnected?: boolean;
    msalConfigured?: boolean;
    systemReady?: boolean;
}

export class SystemSettings implements ISystemSettings {
    id?: string | undefined;
    userId?: string | undefined;
    docker?: DockerSettings;
    ui?: UISettings;
    nginx?: NginxSettings;
    containers?: ContainerSettings;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: ISystemSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.docker = _data["docker"] ? DockerSettings.fromJS(_data["docker"]) : <any>undefined;
            this.ui = _data["ui"] ? UISettings.fromJS(_data["ui"]) : <any>undefined;
            this.nginx = _data["nginx"] ? NginxSettings.fromJS(_data["nginx"]) : <any>undefined;
            this.containers = _data["containers"] ? ContainerSettings.fromJS(_data["containers"]) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SystemSettings {
        data = typeof data === 'object' ? data : {};
        let result = new SystemSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["docker"] = this.docker ? this.docker.toJSON() : <any>undefined;
        data["ui"] = this.ui ? this.ui.toJSON() : <any>undefined;
        data["nginx"] = this.nginx ? this.nginx.toJSON() : <any>undefined;
        data["containers"] = this.containers ? this.containers.toJSON() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISystemSettings {
    id?: string | undefined;
    userId?: string | undefined;
    docker?: DockerSettings;
    ui?: UISettings;
    nginx?: NginxSettings;
    containers?: ContainerSettings;
    createdAt?: Date;
    updatedAt?: Date;
}

export class TestCreateContainerRequest implements ITestCreateContainerRequest {
    name?: string | undefined;
    databaseType?: string | undefined;
    configuration?: { [key: string]: string; } | undefined;

    constructor(data?: ITestCreateContainerRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.databaseType = _data["databaseType"];
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
        }
    }

    static fromJS(data: any): TestCreateContainerRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TestCreateContainerRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["databaseType"] = this.databaseType;
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        return data;
    }
}

export interface ITestCreateContainerRequest {
    name?: string | undefined;
    databaseType?: string | undefined;
    configuration?: { [key: string]: string; } | undefined;
}

export class TokenValidationRequest implements ITokenValidationRequest {
    token?: string | undefined;

    constructor(data?: ITokenValidationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): TokenValidationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TokenValidationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

export interface ITokenValidationRequest {
    token?: string | undefined;
}

export class UISettings implements IUISettings {
    darkMode?: boolean;
    theme?: string | undefined;
    enableAnimations?: boolean;
    refreshInterval?: number;

    constructor(data?: IUISettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.darkMode = _data["darkMode"];
            this.theme = _data["theme"];
            this.enableAnimations = _data["enableAnimations"];
            this.refreshInterval = _data["refreshInterval"];
        }
    }

    static fromJS(data: any): UISettings {
        data = typeof data === 'object' ? data : {};
        let result = new UISettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["darkMode"] = this.darkMode;
        data["theme"] = this.theme;
        data["enableAnimations"] = this.enableAnimations;
        data["refreshInterval"] = this.refreshInterval;
        return data;
    }
}

export interface IUISettings {
    darkMode?: boolean;
    theme?: string | undefined;
    enableAnimations?: boolean;
    refreshInterval?: number;
}

export class UpdateSettingsRequest implements IUpdateSettingsRequest {
    docker?: DockerSettings;
    ui?: UISettings;
    nginx?: NginxSettings;
    containers?: ContainerSettings;

    constructor(data?: IUpdateSettingsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.docker = _data["docker"] ? DockerSettings.fromJS(_data["docker"]) : <any>undefined;
            this.ui = _data["ui"] ? UISettings.fromJS(_data["ui"]) : <any>undefined;
            this.nginx = _data["nginx"] ? NginxSettings.fromJS(_data["nginx"]) : <any>undefined;
            this.containers = _data["containers"] ? ContainerSettings.fromJS(_data["containers"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateSettingsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSettingsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["docker"] = this.docker ? this.docker.toJSON() : <any>undefined;
        data["ui"] = this.ui ? this.ui.toJSON() : <any>undefined;
        data["nginx"] = this.nginx ? this.nginx.toJSON() : <any>undefined;
        data["containers"] = this.containers ? this.containers.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateSettingsRequest {
    docker?: DockerSettings;
    ui?: UISettings;
    nginx?: NginxSettings;
    containers?: ContainerSettings;
}

export class User implements IUser {
    id?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
    createdAt?: Date;
    lastLoginAt?: Date;
    isActive?: boolean;
    containers?: DatabaseContainer[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.name = _data["name"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastLoginAt = _data["lastLoginAt"] ? new Date(_data["lastLoginAt"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["containers"])) {
                this.containers = [] as any;
                for (let item of _data["containers"])
                    this.containers!.push(DatabaseContainer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["name"] = this.name;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastLoginAt"] = this.lastLoginAt ? this.lastLoginAt.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.containers)) {
            data["containers"] = [];
            for (let item of this.containers)
                data["containers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUser {
    id?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
    createdAt?: Date;
    lastLoginAt?: Date;
    isActive?: boolean;
    containers?: DatabaseContainer[] | undefined;
}

export class ValidationResult implements IValidationResult {
    isValid?: boolean;
    message?: string | undefined;
    details?: string | undefined;

    constructor(data?: IValidationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
            this.message = _data["message"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): ValidationResult {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        data["message"] = this.message;
        data["details"] = this.details;
        return data;
    }
}

export interface IValidationResult {
    isValid?: boolean;
    message?: string | undefined;
    details?: string | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}